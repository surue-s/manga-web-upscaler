# MANGA WEB UPSCALER - BROWSER EXTENSION
## Complete Architecture Documentation

================================================================================
## TABLE OF CONTENTS
================================================================================

1. Project Overview
2. Architecture Design
3. Component Breakdown
4. Message Flow & Communication
5. File Structure
6. Technical Implementation Details
7. Installation & Setup
8. Usage Guide
9. Development Guidelines
10. Troubleshooting
11. Future Enhancements

================================================================================
## 1. PROJECT OVERVIEW
================================================================================

### Purpose
A Manifest V3 browser extension that uses AI (RealESRGAN) to upscale manga/anime
images directly in the browser without any server processing. Completely client-side.

### Key Features
- ✅ Manifest V3 compliant (modern Chrome extension standard)
- ✅ ONNX Runtime Web for client-side AI inference
- ✅ Web Worker architecture (non-blocking UI)
- ✅ Automatic image detection on webpages
- ✅ Single-click image upscaling
- ✅ 4x resolution enhancement (256x256 → 1024x1024)
- ✅ No data sent to servers (100% local processing)

### Technology Stack
- **Extension Framework**: Chrome Extension Manifest V3
- **AI Runtime**: ONNX Runtime Web (WebAssembly)
- **Model**: RealESRGAN Anime 4x (6-block RRDB architecture)
- **Languages**: JavaScript (ES6+), HTML5, CSS3
- **Architecture Pattern**: Message-passing distributed system

================================================================================
## 2. ARCHITECTURE DESIGN
================================================================================

### System Components (5 Layers)

The extension is designed as a distributed system with clear separation of concerns:

```
┌─────────────────────────────────────────────────────────────────┐
│                         USER INTERFACE                          │
│                      (popup.html/js/css)                        │
│  - Display status and controls                                  │
│  - Trigger actions                                              │
│  - Show progress/results                                        │
└────────────────┬────────────────────────────────────────────────┘
                 │ chrome.runtime.sendMessage()
                 ↓
┌─────────────────────────────────────────────────────────────────┐
│                      SERVICE WORKER                             │
│                   (service-worker.js)                           │
│  - Route messages between components                            │
│  - Manage Web Worker lifecycle                                  │
│  - Track extension state                                        │
└──────────┬──────────────────────────────────┬───────────────────┘
           │                                   │
           │ chrome.tabs.sendMessage()         │ new Worker()
           ↓                                   ↓
┌──────────────────────────────┐   ┌─────────────────────────────┐
│      CONTENT SCRIPT          │   │      WEB WORKER             │
│    (content/content.js)      │   │ (worker/inference-worker.js)│
│  - Detect images on page     │   │  - Load ONNX Runtime        │
│  - Extract image data        │   │  - Load ONNX model (once)   │
│  - Manipulate DOM            │   │  - Run inference            │
│  - Replace images            │   │  - Return results           │
└──────────────────────────────┘   └─────────────────────────────┘
```

### Communication Flow

All components communicate via structured message passing:

**Popup → Service Worker → Content Script:**
```javascript
User clicks "Upscale" 
  → popup.js sends message to service worker
  → service worker forwards to active tab's content script
  → content script detects images, extracts data
```

**Content Script → Service Worker → Web Worker:**
```javascript
Content script has image tensor
  → sends to service worker
  → service worker forwards to Web Worker
  → Web Worker runs ONNX inference
  → returns upscaled tensor
  → content script replaces image in DOM
```

### Design Principles

1. **Single Responsibility**: Each file has ONE clear purpose
2. **No DOM in Workers**: Web Worker cannot access DOM (browser security)
3. **No Heavy Computation in Main Thread**: All AI inference in Web Worker
4. **Stateless Messages**: Each message is self-contained
5. **Error Isolation**: Failures in one component don't crash others

================================================================================
## 3. COMPONENT BREAKDOWN
================================================================================

### 3.1 manifest.json (Extension Configuration)

**Purpose**: Define extension metadata, permissions, and component registration

**Key Sections**:
- `manifest_version: 3` - Uses Manifest V3 (required for new extensions)
- `permissions` - What the extension can access:
  - `activeTab` - Access current tab when user clicks extension
  - `scripting` - Inject content scripts
  - `storage` - Save user preferences
- `host_permissions` - Access all URLs to detect images
- `action` - Defines popup UI
- `background.service_worker` - Registers background coordinator
- `content_scripts` - Automatically inject content script on all pages
- `web_accessible_resources` - Allow content script to load ONNX model
- `content_security_policy` - Allow WebAssembly execution

**Critical Detail**: 
- `'wasm-unsafe-eval'` in CSP is REQUIRED for ONNX Runtime Web
- Without it, WebAssembly compilation will fail

---

### 3.2 popup/ (User Interface)

#### popup.html
**Purpose**: Extension popup UI structure

**Elements**:
- Status display (extension state, model status, image count)
- Action buttons (Detect, Upscale Single, Upscale All)
- Progress indicator
- Result/error messages

**Design**: Clean, modern, gradient theme (purple/blue)

#### popup.js
**Purpose**: Handle user interactions and UI updates

**Key Functions**:
- `initialize()` - Check model status, auto-detect images on popup open
- `detectImages()` - Ask content script to scan page for images
- `upscaleSingle()` - Trigger single image upscale
- `showProgress()` - Update progress bar during processing
- `showResult()`/`showError()` - Display outcome

**Message Flow**:
```javascript
User clicks button
  → popup.js sends message to content script via chrome.tabs.sendMessage()
  → waits for response
  → updates UI based on result
```

#### popup.css
**Purpose**: Styling for popup UI

**Features**:
- Gradient background
- Smooth animations
- Responsive button states
- Progress bar visualization
- Success/error message styling

---

### 3.3 content/content.js (DOM Interaction Layer)

**Purpose**: The ONLY component that can access and modify the webpage DOM

**Key Responsibilities**:
1. **Image Detection**:
   - Scan page for `<img>` elements
   - Filter by visibility (skip hidden images)
   - Filter by size (skip icons, skip already-high-res)
   - Return count to popup

2. **Image Data Extraction**:
   - Create canvas element
   - Draw image to canvas
   - Extract ImageData (RGBA pixel array)
   - Handle cross-origin restrictions

3. **Tensor Conversion**:
   - Convert ImageData (RGBA, HWC format) to Float32Array (RGB, CHW format)
   - Normalize pixels from [0, 255] to [0, 1]
   - Prepare tensor for ONNX model input

4. **DOM Replacement**:
   - Create canvas with upscaled result
   - Convert to Blob → Object URL
   - Replace original image src
   - Track upscaled images to avoid duplicates

**Critical Functions**:

```javascript
detectImages()
  → Returns list of <img> elements suitable for upscaling
  
extractImageData(imgElement)
  → Returns { data: Uint8ClampedArray, width, height }
  
imageDataToTensor(imageData)
  → Returns { tensor: Float32Array, dims: [1, 3, H, W] }
  
tensorToImageData(tensor, width, height)
  → Returns ImageData object for canvas rendering
  
replaceImage(imgElement, upscaledImageData)
  → Swaps image in DOM with upscaled version
```

**Security Notes**:
- Uses `crossOrigin = 'anonymous'` to handle CORS
- Catches errors for cross-origin images
- Stores original src in `dataset.originalSrc` for potential undo

---

### 3.4 service-worker.js (Message Coordinator)

**Purpose**: Act as central message router between all components

**Key Responsibilities**:
1. **Worker Management**:
   - Create Web Worker on first use
   - Reuse same worker for all requests (avoid reload overhead)
   - Track worker state (ready, model loaded)

2. **Message Routing**:
   - Receive messages from popup/content script
   - Forward to Web Worker
   - Return responses back to sender

3. **State Tracking**:
   - Track if model is loaded
   - Track if worker is ready
   - Respond to status checks

**Key Functions**:

```javascript
initializeWorker()
  → Creates Web Worker instance (once per session)
  
sendToWorker(message)
  → Sends message to worker, returns Promise with result
  
chrome.runtime.onMessage.addListener()
  → Handles all incoming messages from popup/content script
```

**Message Types Handled**:
- `CHECK_MODEL_STATUS` - Return current model state
- `LOAD_MODEL` - Explicitly load model (usually auto-loaded)
- `UPSCALE_IMAGE` - Forward tensor to worker for inference

**Why Needed?**:
Manifest V3 doesn't allow persistent background pages. Service worker:
- Can be terminated by browser at any time
- Must be stateless (no long-term variables)
- Coordinates between isolated contexts (popup, content script, worker)

---

### 3.5 worker/inference-worker.js (AI Engine)

**Purpose**: Run ONNX model inference in isolated thread

**Key Responsibilities**:
1. **ONNX Runtime Loading**:
   - Import ONNX Runtime Web library
   - Configure WASM backend
   - Enable SIMD optimizations

2. **Model Loading**:
   - Fetch ONNX model file (.onnx)
   - Create InferenceSession (one-time, cached)
   - Prepare for inference

3. **Inference Execution**:
   - Receive input tensor from service worker
   - Create ONNX Tensor object
   - Run model.run()
   - Return output tensor

**Key Functions**:

```javascript
loadONNXRuntime()
  → Loads onnxruntime-web library via importScripts()
  
loadModel()
  → Fetches ONNX model, creates InferenceSession (cached)
  
runInference(inputTensor, inputDims)
  → Runs model on input, returns output tensor
```

**Performance Optimizations**:
- Model loaded ONCE per session (expensive operation)
- Session reused for all inferences
- Runs in separate thread (doesn't block UI)
- Uses WebAssembly (faster than pure JS)

**Message Protocol**:
```javascript
// Input message format
{
  type: 'RUN_INFERENCE',
  payload: {
    tensor: [/* Float32Array as regular array */],
    dims: [1, 3, 256, 256]
  },
  messageId: 12345 // For response matching
}

// Output message format
{
  type: 'INFERENCE_COMPLETE',
  payload: {
    tensor: [/* output Float32Array as array */],
    outputDims: [1, 3, 1024, 1024]
  },
  messageId: 12345
}
```

**Why Web Worker?**:
- Main thread must stay responsive for UI
- AI inference is compute-intensive (blocks thread)
- Web Workers run in parallel (true concurrency)
- Browser prevents UI freezing

================================================================================
## 4. MESSAGE FLOW & COMMUNICATION
================================================================================

### Complete Message Flow Example: "Upscale Single Image"

**Step-by-step breakdown:**

```
1. USER ACTION
   User clicks "Upscale Single Image" button in popup

2. POPUP → CONTENT SCRIPT (via chrome.tabs.sendMessage)
   Message: { type: 'UPSCALE_SINGLE' }
   
3. CONTENT SCRIPT
   - Detects images on page
   - Selects first suitable image
   - Extracts image data from DOM
   - Converts to tensor: Float32Array [1, 3, H, W]
   
4. CONTENT SCRIPT → SERVICE WORKER (via chrome.runtime.sendMessage)
   Message: {
     type: 'UPSCALE_IMAGE',
     payload: {
       tensor: Array.from(Float32Array),
       dims: [1, 3, 256, 256],
       originalWidth: 256,
       originalHeight: 256
     }
   }
   
5. SERVICE WORKER → WEB WORKER (via postMessage)
   Message: {
     type: 'RUN_INFERENCE',
     payload: { tensor, dims },
     messageId: 12345
   }
   
6. WEB WORKER
   - Receives tensor
   - Creates ONNX Tensor object
   - Runs session.run(feeds)
   - Gets output: [1, 3, 1024, 1024]
   
7. WEB WORKER → SERVICE WORKER (via postMessage)
   Message: {
     type: 'INFERENCE_COMPLETE',
     payload: {
       tensor: Array.from(outputTensor.data),
       outputDims: [1, 3, 1024, 1024]
     },
     messageId: 12345
   }
   
8. SERVICE WORKER → CONTENT SCRIPT (response)
   Message: {
     success: true,
     tensor: [...],
     width: 1024,
     height: 1024
   }
   
9. CONTENT SCRIPT
   - Converts tensor back to ImageData
   - Creates canvas with upscaled image
   - Converts to Blob → Object URL
   - Replaces original <img> src in DOM
   
10. CONTENT SCRIPT → POPUP (response)
    Message: { success: true }
    
11. POPUP
    - Updates UI: "Complete!"
    - Shows success message
```

**Total Time**: ~500-2000ms depending on image size and hardware

**Critical Points**:
- Each arrow (→) is a message boundary
- Messages are async (non-blocking)
- Errors can occur at any step (try/catch at each layer)
- Each component validates messages before processing

================================================================================
## 5. FILE STRUCTURE
================================================================================

```
extension/
├── manifest.json                  # Extension configuration
│
├── icons/                         # Extension icons
│   ├── icon16.png                 # 16x16 (toolbar)
│   ├── icon48.png                 # 48x48 (extensions page)
│   └── icon128.png                # 128x128 (Chrome Web Store)
│
├── popup/                         # Popup UI
│   ├── popup.html                 # UI structure
│   ├── popup.js                   # UI logic
│   └── popup.css                  # UI styling
│
├── content/                       # Content script
│   └── content.js                 # DOM interaction layer
│
├── service-worker.js              # Background coordinator
│
├── worker/                        # Web Worker
│   └── inference-worker.js        # ONNX inference engine
│
├── models/                        # AI models
│   └── esrgan_anime_model.onnx    # RealESRGAN model (copy from /onnx/)
│
└── lib/                           # External libraries (optional)
    └── ort.min.js                 # ONNX Runtime Web (or use CDN)
```

**File Sizes** (approximate):
- manifest.json: 1 KB
- popup files: 10 KB total
- content.js: 8 KB
- service-worker.js: 5 KB
- inference-worker.js: 6 KB
- esrgan_anime_model.onnx: **480 KB** (main payload)
- Total extension: ~500 KB

================================================================================
## 6. TECHNICAL IMPLEMENTATION DETAILS
================================================================================

### 6.1 Tensor Format Conversion

**Why Needed?**:
- Browser ImageData: RGBA, HWC format (Height × Width × Channels)
- ONNX Model expects: RGB, CHW format (Channels × Height × Width)
- Must convert between formats before/after inference

**Input Conversion (ImageData → Tensor)**:

```javascript
// ImageData format: [R, G, B, A, R, G, B, A, ...] (RGBA pixels in row-major order)
// Target format: [R, R, R, ..., G, G, G, ..., B, B, B, ...] (CHW)

const tensor = new Float32Array(3 * width * height);
for (let h = 0; h < height; h++) {
  for (let w = 0; w < width; w++) {
    const pixelIndex = (h * width + w) * 4; // RGBA source
    const tensorIndex = h * width + w;       // CHW target
    
    tensor[0 * width * height + tensorIndex] = data[pixelIndex + 0] / 255.0; // R
    tensor[1 * width * height + tensorIndex] = data[pixelIndex + 1] / 255.0; // G
    tensor[2 * width * height + tensorIndex] = data[pixelIndex + 2] / 255.0; // B
  }
}
```

**Output Conversion (Tensor → ImageData)**:

```javascript
// Reverse: CHW → RGBA HWC
for (let h = 0; h < height; h++) {
  for (let w = 0; w < width; w++) {
    const pixelIndex = (h * width + w) * 4;
    const tensorIndex = h * width + w;
    
    data[pixelIndex + 0] = tensor[0 * width * height + tensorIndex] * 255; // R
    data[pixelIndex + 1] = tensor[1 * width * height + tensorIndex] * 255; // G
    data[pixelIndex + 2] = tensor[2 * width * height + tensorIndex] * 255; // B
    data[pixelIndex + 3] = 255; // Alpha (fully opaque)
  }
}
```

### 6.2 Cross-Origin Image Handling

**Problem**: 
Browsers block canvas.getImageData() for cross-origin images (CORS security)

**Solution**:
```javascript
const img = new Image();
img.crossOrigin = 'anonymous'; // Request CORS-enabled version
img.onload = () => {
  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, width, height); // Works now
};
img.onerror = () => {
  // Handle CORS failure (some sites don't allow)
};
img.src = originalImage.src;
```

**Fallback**: If CORS fails, image cannot be upscaled (browser security restriction)

### 6.3 Memory Management

**Concerns**:
- Large tensors (256×256×3×4 bytes = 768 KB per image)
- ONNX model (~500 KB)
- Output tensors (1024×1024×3×4 bytes = 12 MB per output)

**Strategies**:
1. **Model Caching**: Load model once, reuse for all inferences
2. **Transferable Objects**: Use ArrayBuffer transfer (zero-copy messaging)
3. **Cleanup**: Revoke Object URLs after image replacement
4. **Avoid Copies**: Convert arrays in-place where possible

**Example (zero-copy messaging)**:
```javascript
// Transfer ArrayBuffer ownership (no copy)
worker.postMessage({ tensor: buffer }, [buffer]);
```

### 6.4 Error Handling Strategy

**Principle**: Fail gracefully at each layer

**Levels**:
1. **Worker**: Catch ONNX errors, send error message
2. **Service Worker**: Catch worker errors, forward to content script
3. **Content Script**: Catch extraction errors, report to popup
4. **Popup**: Display user-friendly error message

**Example**:
```javascript
try {
  const result = await runInference(tensor, dims);
  return { success: true, result };
} catch (error) {
  console.error('[Worker] Inference failed:', error);
  return { success: false, error: error.message };
}
```

================================================================================
## 7. INSTALLATION & SETUP
================================================================================

### Prerequisites
1. Chrome or Chromium-based browser (Edge, Brave, Opera)
2. ONNX model file: `esrgan_anime_model.onnx` (from /onnx/ directory)

### Step 1: Copy ONNX Model
```bash
# Copy the ONNX model to extension directory
cp onnx/esrgan_anime_model.onnx extension/models/
```

### Step 2: Create Extension Icons
Create 3 PNG icons (or use placeholder):
- `extension/icons/icon16.png` (16×16)
- `extension/icons/icon48.png` (48×48)
- `extension/icons/icon128.png` (128×128)

### Step 3: Load Extension in Chrome
1. Open Chrome
2. Navigate to `chrome://extensions/`
3. Enable "Developer mode" (top-right toggle)
4. Click "Load unpacked"
5. Select the `extension/` directory
6. Extension should appear in toolbar

### Step 4: Test Extension
1. Navigate to any manga reading website
2. Click extension icon (popup opens)
3. Click "Detect Images" → should show image count
4. Click "Upscale Single Image" → first image should upscale
5. Check console (F12) for debug logs

### Troubleshooting Installation
- **"Manifest file is missing or unreadable"**: Check manifest.json syntax
- **CSP errors**: Ensure `'wasm-unsafe-eval'` in content_security_policy
- **Worker not loading**: Check browser console for CORS/import errors
- **Model not found**: Verify `esrgan_anime_model.onnx` in models/

================================================================================
## 8. USAGE GUIDE
================================================================================

### Basic Usage Flow

1. **Open a webpage with images** (manga site, gallery, etc.)

2. **Click extension icon** → Popup opens

3. **Detection** (automatic or manual):
   - Popup auto-detects images on open
   - Or click "Detect Images" button
   - Shows count: "Images detected: 5"

4. **Upscale single image**:
   - Click "Upscale Single Image"
   - Progress bar shows: Loading model → Processing → Complete
   - First detected image on page is upscaled
   - Result: 4x resolution (e.g., 256×256 → 1024×1024)

5. **View result**:
   - Image on page is automatically replaced
   - Original quality is lost (replaced with upscaled version)
   - Refresh page to restore original

### What Images Are Upscaled?

**Included**:
- Visible images (not hidden)
- Medium-sized images (100-2000px width/height)
- Standard web images (JPEG, PNG, WebP)

**Excluded**:
- Tiny images (<100px) - likely icons/avatars
- Very large images (>2000px) - already high-res
- Hidden images (display:none, visibility:hidden)
- Already upscaled images (tracked in memory)

### Performance Expectations

**Single Image (256×256)**:
- Model load (first time): ~2-3 seconds
- Inference: ~500-2000ms depending on device
- DOM replacement: ~100ms

**Hardware Impact**:
- CPU: High usage during inference (~100%)
- RAM: ~100-200 MB for model + tensors
- GPU: Not used (WASM backend only)

================================================================================
## 9. DEVELOPMENT GUIDELINES
================================================================================

### Code Organization Principles

1. **One file, one responsibility**:
   - popup.js = UI only
   - content.js = DOM only
   - service-worker.js = routing only
   - inference-worker.js = AI only

2. **No cross-layer violations**:
   - Worker CANNOT access DOM (will crash)
   - Content script CANNOT run heavy computation (will freeze page)
   - Popup CANNOT manipulate page DOM (wrong context)

3. **Message-driven architecture**:
   - All communication via postMessage or chrome.runtime.sendMessage
   - Messages are async (always use Promises)
   - Include error handling for every message

### Extending the Extension

**Add new feature: "Upscale All Images"**

1. **popup.js**: Wire up button click
   ```javascript
   upscaleAllBtn.addEventListener('click', async () => {
     await sendToContentScript({ type: 'UPSCALE_ALL' });
   });
   ```

2. **content.js**: Handle message
   ```javascript
   else if (message.type === 'UPSCALE_ALL') {
     const images = detectImages();
     for (const img of images) {
       await upscaleImage(img);
     }
     sendResponse({ success: true, count: images.length });
   }
   ```

3. **No changes needed** in service-worker.js or inference-worker.js (reuse existing)

**Add new model:**

1. Export new ONNX model to `models/new_model.onnx`
2. Update inference-worker.js:
   ```javascript
   const modelUrl = '../models/new_model.onnx';
   ```
3. Adjust preprocessing if model expects different input format

### Debugging Tips

**Enable verbose logging:**
```javascript
// Add at top of each file
const DEBUG = true;
if (DEBUG) console.log('[Component] Debug message');
```

**Check message flow:**
1. Open extension popup
2. Open DevTools (F12) → Console
3. Click action → watch console for message chain:
   - `[Popup] Sending message: UPSCALE_SINGLE`
   - `[Content] Received message: UPSCALE_SINGLE`
   - `[Service Worker] Received message: UPSCALE_IMAGE`
   - `[Worker] Running inference...`
   - `[Worker] Inference complete`

**Common issues:**
- **Popup not opening**: Check manifest.json syntax
- **Content script not injected**: Check `matches` in manifest
- **Worker not responding**: Check console for ONNX load errors
- **Image not upscaling**: Check tensor shape (log dims)

================================================================================
## 10. TROUBLESHOOTING
================================================================================

### Issue: "Model not found" error

**Symptoms**: Worker logs "Failed to fetch model"

**Causes**:
- Model file not in `extension/models/`
- Wrong model filename in inference-worker.js

**Fix**:
```bash
# Verify model exists
ls extension/models/esrgan_anime_model.onnx

# Check filename matches in inference-worker.js line 54
const modelUrl = '../models/esrgan_anime_model.onnx';
```

---

### Issue: "WASM initialization failed"

**Symptoms**: Worker logs "Failed to load ONNX Runtime"

**Causes**:
- Missing `'wasm-unsafe-eval'` in CSP
- ONNX Runtime CDN blocked

**Fix**:
```json
// manifest.json
"content_security_policy": {
  "extension_pages": "script-src 'self' 'wasm-unsafe-eval'; object-src 'self';"
}
```

---

### Issue: "Cross-origin image error"

**Symptoms**: Content script logs "Failed to extract image data"

**Causes**:
- Website doesn't allow CORS
- Image from different domain without CORS headers

**Fix**: This is a browser security restriction. Cannot bypass.
- Try on same-origin images only
- Or request website to add CORS headers

---

### Issue: Extension icons not showing

**Symptoms**: Gray icon in toolbar

**Causes**:
- Missing icon files
- Wrong paths in manifest.json

**Fix**:
```bash
# Create placeholder icons (any PNG editor)
# Or use online generator: https://favicon.io/

# Verify paths in manifest.json
"icons": {
  "16": "icons/icon16.png",  # Must exist
  "48": "icons/icon48.png",
  "128": "icons/icon128.png"
}
```

---

### Issue: Service worker inactive/terminated

**Symptoms**: Messages not routing between components

**Causes**:
- Manifest V3 service workers are ephemeral (browser terminates them)

**Fix**: This is expected behavior. Service worker restarts automatically.
- Ensure no persistent state in service worker
- Use chrome.storage.local for persistent data

---

### Issue: Out of memory errors

**Symptoms**: Browser tab crashes during inference

**Causes**:
- Very large images
- Multiple inferences in parallel

**Fix**:
```javascript
// In content.js, limit image size
if (img.naturalWidth > 1000 || img.naturalHeight > 1000) {
  console.warn('Image too large, skipping');
  return;
}
```

================================================================================
## 11. FUTURE ENHANCEMENTS
================================================================================

### Phase 2: Tiling Strategy (for large images)

**Problem**: Large images (>2000px) exceed WASM memory limits

**Solution**: Divide image into 512×512 tiles, upscale separately, stitch together

**Implementation**:
```javascript
// In content.js
function tileImage(imageData, tileSize = 512) {
  const tiles = [];
  for (let y = 0; y < height; y += tileSize) {
    for (let x = 0; x < width; x += tileSize) {
      const tile = extractTile(imageData, x, y, tileSize);
      tiles.push({ tile, x, y });
    }
  }
  return tiles;
}

async function upscaleTiled(imageData) {
  const tiles = tileImage(imageData);
  const upscaledTiles = await Promise.all(
    tiles.map(({ tile, x, y }) => upscaleTile(tile, x, y))
  );
  return stitchTiles(upscaledTiles, width * 4, height * 4);
}
```

**Overlap Strategy**: Add 8-16px overlap between tiles to avoid seams

---

### Phase 3: INT8 Quantization

**Goal**: Reduce model size from 480 KB → ~120 KB

**Benefits**:
- Faster load time
- Less memory usage
- Slightly faster inference

**Process**:
```python
# In tools/ directory
from onnxruntime.quantization import quantize_dynamic

quantize_dynamic(
    'esrgan_anime_model.onnx',
    'esrgan_anime_model_int8.onnx',
    weight_type='int8'
)
```

**Trade-off**: Slightly lower quality (~1-2% PSNR loss)

---

### Phase 4: WebGPU Backend

**Goal**: Use GPU for inference (10-50x faster than WASM)

**Requirements**:
- Browser must support WebGPU (Chrome 113+)
- Fallback to WASM if unavailable

**Implementation**:
```javascript
// In inference-worker.js
const providers = ['webgpu', 'wasm']; // Try WebGPU first
session = await ort.InferenceSession.create(modelBuffer, {
  executionProviders: providers
});
```

**Expected Performance**:
- WASM: ~1000ms for 256×256
- WebGPU: ~50-100ms for 256×256

---

### Phase 5: Batch Processing

**Goal**: Upscale all images on page automatically

**UI Changes**:
- "Upscale All" button functional
- Progress bar shows "Image 3/10"
- Option to cancel mid-batch

**Implementation**:
```javascript
async function upscaleAll() {
  const images = detectImages();
  for (let i = 0; i < images.length; i++) {
    updateProgress((i / images.length) * 100);
    await upscaleImage(images[i]);
  }
}
```

**Consideration**: Parallel vs sequential (memory usage)

---

### Phase 6: User Preferences

**Features**:
- Model selection (anime vs photo)
- Upscale factor (2x vs 4x)
- Auto-upscale toggle (on page load)
- Exclude domains (blacklist)

**Storage**:
```javascript
// Save preferences
await chrome.storage.local.set({
  autoUpscale: true,
  upscaleFactor: 4,
  excludedDomains: ['example.com']
});

// Load preferences
const prefs = await chrome.storage.local.get(['autoUpscale']);
```

---

### Phase 7: Chrome Web Store Distribution

**Requirements**:
1. Create promotional images (1400×560, 640×400)
2. Write detailed description
3. Set up privacy policy (no data collection)
4. Set pricing ($0 - free)
5. Submit for review

**Monetization Options**:
- Free with optional donations
- Pro version with batch processing
- One-time purchase

================================================================================
## APPENDIX: Message Schemas
================================================================================

### Popup → Content Script
```javascript
{ type: 'DETECT_IMAGES' }
{ type: 'UPSCALE_SINGLE' }
{ type: 'UPSCALE_ALL' }
```

### Content Script → Popup (responses)
```javascript
{ count: 5 }
{ success: true }
{ success: false, error: 'message' }
```

### Content Script → Service Worker
```javascript
{
  type: 'UPSCALE_IMAGE',
  payload: {
    tensor: Float32Array,
    dims: [1, 3, 256, 256],
    originalWidth: 256,
    originalHeight: 256
  }
}
```

### Service Worker → Web Worker
```javascript
{
  type: 'RUN_INFERENCE',
  payload: { tensor, dims },
  messageId: 12345
}
```

### Web Worker → Service Worker
```javascript
{
  type: 'INFERENCE_COMPLETE',
  payload: {
    tensor: Float32Array,
    outputDims: [1, 3, 1024, 1024]
  },
  messageId: 12345
}
```

================================================================================
END OF DOCUMENTATION
================================================================================

Created: January 2026
Project: Manga Web Upscaler Browser Extension
Architecture: Manifest V3, Message-Passing, Web Worker
AI Model: RealESRGAN Anime 4x (ONNX format)
Status: Core skeleton complete, ready for testing and enhancement
